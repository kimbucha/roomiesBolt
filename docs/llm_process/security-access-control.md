TITLE: Postgres Column-Level Security (CLS) Grants
DESCRIPTION: Documentation for managing fine-grained column-level grants in Postgres via the Supabase dashboard. This allows specific permissions for roles like `anon` and `service_role` when combined with Row Level Security (RLS) for comprehensive data access control.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2024-07-11-hardening-supabase.mdx#_snippet_1

LANGUAGE: APIDOC
CODE:
```
Feature: Column-Level Security (CLS)
Description: Manage granular permissions on individual table columns.
Mechanism: Postgres GRANT statements
Dashboard Path: Supabase Dashboard -> Project -> Database -> Column Privileges
Applicable Roles: All Postgres roles, including Supabase default roles (`anon`, `service_role`)
Integration: Works in conjunction with Row Level Security (RLS) for comprehensive data access control.
Example Grant Concept:
  GRANT SELECT (column_name) ON table_name TO role_name;
  GRANT UPDATE (column_name) ON table_name TO role_name;
Benefits:
  - Restrict access to sensitive columns.
  - Provide different views of data based on user roles.
```

----------------------------------------

TITLE: Grant Read Access to Supabase Storage Bucket using SQL Policy
DESCRIPTION: This SQL policy grants read (SELECT) access to all objects within a specified bucket, 'avatars', in the Supabase storage system. It leverages Postgres Row Level Security (RLS) on the `storage.objects` table to control access.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2021-03-30-supabase-storage.mdx#_snippet_0

LANGUAGE: SQL
CODE:
```
create policy "Read access for avatars."
on storage.objects for select using (
	bucket_id = 'avatars'
);
```

----------------------------------------

TITLE: Add security policy for Supabase Storage objects using SQL
DESCRIPTION: This SQL snippet creates a security policy to allow public read access (SELECT) to objects within a specific bucket in Supabase Storage. Policies are essential for controlling access to your files.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/storage/quickstart.mdx#_snippet_3

LANGUAGE: SQL
CODE:
```
create policy "Public Access"
  on storage.objects for select
  using ( bucket_id = 'public' );
```

----------------------------------------

TITLE: Allow Individual User Access to Own Uploaded Files
DESCRIPTION: An SQL policy that grants authenticated users `SELECT` access only to files they previously uploaded, by comparing their `auth.uid()` with the `owner_id` of the object.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/storage/security/access-control.mdx#_snippet_4

LANGUAGE: sql
CODE:
```
create policy "Individual user Access"
on storage.objects for select
to authenticated
using ( (select auth.uid()) = owner_id::uuid );
```

----------------------------------------

TITLE: Adding Security Policy with SQL
DESCRIPTION: This SQL snippet demonstrates how to create a new Row Level Security (RLS) policy named 'Public Access' on the `storage.objects` table. This policy grants `SELECT` (read) access to objects only if their `bucket_id` is 'public', effectively making files in the 'public' bucket accessible to all users.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/storage/quickstart.mdx#_snippet_11

LANGUAGE: SQL
CODE:
```
create policy "Public Access"
  on storage.objects for select
  using ( bucket_id = 'public' );
```

----------------------------------------

TITLE: Altering View Security to Security Invoker in PostgreSQL
DESCRIPTION: This SQL snippet shows how to change a view's security setting from `security definer` (default) to `security invoker`. When set to `security invoker`, the view enforces row-level security policies based on the permissions of the user executing the query, rather than the view's creator. This is crucial for applying fine-grained access control.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/tables.mdx#_snippet_19

LANGUAGE: SQL
CODE:
```
-- alter a security_definer view to be security_invoker
alter view <view name>
set (security_invoker = true);
```

----------------------------------------

TITLE: SQL Schema: Public Tables for Realtime Authorization Examples
DESCRIPTION: This SQL schema defines three public tables: `rooms`, `profiles`, and `rooms_users`. These tables are used in subsequent examples to demonstrate how Row Level Security policies can be applied for Realtime Authorization, enabling fine-grained control over channel access and user data.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/realtime/authorization.mdx#_snippet_1

LANGUAGE: SQL
CODE:
```
create table public.rooms (
    id bigint generated by default as identity primary key,
    topic text not null unique
);

alter table public.rooms enable row level security;

create table public.profiles (
  id uuid not null references auth.users on delete cascade,
  email text NOT NULL,

  primary key (id)
);

alter table public.profiles enable row level security;

create table public.rooms_users (
  user_id uuid references auth.users (id),
  room_topic text references public.rooms (topic),
  created_at timestamptz default current_timestamp
);

alter table public.rooms_users enable row level security;
```

----------------------------------------

TITLE: Enable Row Level Security for a table
DESCRIPTION: SQL command to enable Row Level Security on a specified table. Once enabled, no data will be accessible via the API using the public `anon` key until policies are created.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/postgres/row-level-security.mdx#_snippet_0

LANGUAGE: SQL
CODE:
```
alter table "table_name" enable row level security;
```

----------------------------------------

TITLE: Creating `authorize` Function for RLS in PostgreSQL
DESCRIPTION: This PostgreSQL function, `public.authorize`, is designed to implement Role-Based Access Control (RBAC) within Row Level Security (RLS) policies. It retrieves the `user_role` from the user's JWT, then checks if that role has the `requested_permission` by querying the `public.role_permissions` table, returning `true` if authorized.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/postgres/custom-claims-and-role-based-access-control-rbac.mdx#_snippet_4

LANGUAGE: sql
CODE:
```
create or replace function public.authorize(
  requested_permission app_permission
)
returns boolean as $$
declare
  bind_permissions int;
  user_role public.app_role;
begin
  -- Fetch user role once and store it to reduce number of calls
  select (auth.jwt() ->> 'user_role')::public.app_role into user_role;

  select count(*)
  into bind_permissions
  from public.role_permissions
  where role_permissions.permission = requested_permission
    and role_permissions.role = user_role;

  return bind_permissions > 0;
end;
$$ language plpgsql stable security definer set search_path = '';
```

----------------------------------------

TITLE: Define Row Level Security Policies for Supabase Chat Application
DESCRIPTION: SQL script to establish Row Level Security (RLS) policies for `public.profiles`, `public.rooms`, `public.rooms_users`, and `realtime.messages` tables. These policies control read and write access, ensuring that users can only interact with data they are authorized for, especially for Realtime Broadcast and Presence features based on `public.rooms_users` entries.
SOURCE: https://github.com/supabase/supabase/blob/master/examples/realtime/nextjs-authorization-demo/README.md#_snippet_1

LANGUAGE: sql
CODE:
```
CREATE POLICY "authenticated can view all profiles"
ON "public"."profiles"
AS PERMISSIVE FOR SELECT
TO authenticated
USING (true);

CREATE POLICY "supabase_auth_admin can insert profile"
ON "public"."profiles"
AS PERMISSIVE FOR INSERT
TO supabase_auth_admin
WITH CHECK (true);

CREATE POLICY "authenticated can read rooms"
ON "public"."rooms"
AS PERMISSIVE FOR SELECT
TO authenticated
USING (TRUE);

CREATE POLICY "authenticated can add rooms"
ON "public"."rooms"
AS PERMISSIVE FOR INSERT
TO authenticated
WITH CHECK (TRUE);

CREATE POLICY "authenticated can read rooms_users"
ON "public"."rooms_users"
AS PERMISSIVE FOR SELECT
TO authenticated
USING (TRUE);

CREATE POLICY "authenticated can add rooms_users"
ON "public"."rooms_users"
AS PERMISSIVE FOR INSERT
TO authenticated
WITH CHECK (TRUE);

CREATE POLICY "authenticated can read broadcast and presence state"
ON "realtime"."messages"
AS PERMISSIVE FOR SELECT
TO authenticated
USING (
  EXISTS (
    SELECT 1
    FROM public.rooms_users
    WHERE user_id = (select auth.uid())
    AND room_topic = realtime.topic()
    AND realtime.messages.extension in ('broadcast', 'presence')
  )
);

CREATE POLICY "authenticated can send broadcast and track presence"
ON "realtime"."messages"
AS PERMISSIVE FOR INSERT
TO authenticated
WITH CHECK (
  EXISTS (
    SELECT 1
    FROM public.rooms_users
    WHERE user_id = (select auth.uid())
    AND room_topic = realtime.topic()
    AND realtime.messages.extension in ('broadcast', 'presence')
  )
);
```

----------------------------------------

TITLE: SQL Schema for Private Projects Table with RLS and Public View
DESCRIPTION: Defines the `private.projects` table with columns, enables Row Level Security (RLS), and establishes `INSERT` and `SELECT` policies for authenticated users based on custom `auth.can_write` and `auth.can_read` functions. It also creates a `public.projects` view that exposes a filtered subset of the private table, demonstrating attribute-based access control (ABAC).
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2025-04-03-declarative-schemas.mdx#_snippet_1

LANGUAGE: SQL
CODE:
```
create table private.projects (
  id              bigint    not null,
  name            text      not null,
  organization_id bigint    not null,
  inserted_at     timestamp not null,
  updated_at      timestamp not null
);

alter table private.projects
enable row level security;

create policy projects_insert
  on private.projects
  for insert
  to authenticated
with check auth.can_write(project_id);

create policy projects_select
  on private.projects
  for select
  to authenticated
using auth.can_read(project_id);

-- Users can only view the projects that they have access to
create view public.projects as select
  projects.id,
  projects.name,
  projects.organization_id,
  projects.inserted_at,
  projects.updated_at
from private.projects
where auth.can_read(projects.id);
```

----------------------------------------

TITLE: Define Supabase Storage Access Policies
DESCRIPTION: These SQL statements define three access control policies for objects within Supabase Storage. They enable read access for all users, insert access for authenticated and anonymous users, and update access for all users, ensuring basic CRUD operations on stored objects.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/_partials/product_management_sql_template.mdx#_snippet_2

LANGUAGE: SQL
CODE:
```
CREATE POLICY "Enable read access for all users" ON "storage"."objects"
AS PERMISSIVE FOR SELECT
TO public
USING (true)

CREATE POLICY "Enable insert for all users" ON "storage"."objects"
AS PERMISSIVE FOR INSERT
TO authenticated, anon
WITH CHECK (true)

CREATE POLICY "Enable update for all users" ON "storage"."objects"
AS PERMISSIVE FOR UPDATE
TO public
USING (true)
WITH CHECK (true)
```

----------------------------------------

TITLE: Enable Row Level Security for a Table (SQL)
DESCRIPTION: Demonstrates how to enable Row Level Security (RLS) on a specific table using a SQL ALTER TABLE statement. This is necessary for tables not created via the Supabase Dashboard to protect data by allowing policies to control access.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/api/securing-your-api.mdx#_snippet_0

LANGUAGE: sql
CODE:
```
alter table
  todos enable row level security;
```

----------------------------------------

TITLE: Securely Retrieve Secrets from Vault with get_secret Function
DESCRIPTION: This PL/pgSQL function allows authorized roles (service_role or postgres user) to securely retrieve decrypted secrets by name from the `vault.decrypted_secrets` table. It enforces access control to protect sensitive environment variables.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2024-11-13-supabase-dynamic-functions.mdx#_snippet_2

LANGUAGE: SQL
CODE:
```
CREATE OR REPLACE FUNCTION edge.get_secret(secret_name text) RETURNS text
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    decrypted text;
BEGIN
    IF current_setting('request.jwt.claims', true)::jsonb->>'role' = 'service_role' OR current_user = 'postgres' THEN
        SELECT decrypted_secret
        INTO decrypted
        FROM vault.decrypted_secrets
        WHERE name = secret_name;
        RETURN decrypted;
    ELSE
        RAISE EXCEPTION 'Access denied: only service_role or postgres user can execute this function.';
    END IF;
END;
$$;
```

----------------------------------------

TITLE: Initial RLS Policy for All Inserts
DESCRIPTION: A basic SQL policy to allow all `INSERT` operations on the `storage.objects` table. This serves as a starting point for more restrictive policies.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/storage/security/access-control.mdx#_snippet_0

LANGUAGE: sql
CODE:
```
create policy "policy_name"
ON storage.objects
for insert with check (
  true
);
```

----------------------------------------

TITLE: Creating User Roles and Permissions Tables in SQL
DESCRIPTION: This SQL script defines custom types for application roles (`app_role`) and permissions (`app_permission`), then creates two tables: `user_roles` to assign roles to users, and `role_permissions` to map specific permissions to each role. This setup forms the foundation for implementing role-based access control within the application.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/postgres/custom-claims-and-role-based-access-control-rbac.mdx#_snippet_1

LANGUAGE: sql
CODE:
```
-- Custom types
create type public.app_permission as enum ('channels.delete', 'messages.delete');
create type public.app_role as enum ('admin', 'moderator');

-- USER ROLES
create table public.user_roles (
  id        bigint generated by default as identity primary key,
  user_id   uuid references auth.users on delete cascade not null,
  role      app_role not null,
  unique (user_id, role)
);
comment on table public.user_roles is 'Application roles for each user.';

-- ROLE PERMISSIONS
create table public.role_permissions (
  id           bigint generated by default as identity primary key,
  role         app_role not null,
  permission   app_permission not null,
  unique (role, permission)
);
comment on table public.role_permissions is 'Application permissions for each role.';
```

----------------------------------------

TITLE: Implement Row Level Security Policies for Supabase Tables (SQL)
DESCRIPTION: This SQL snippet enables Row Level Security (RLS) for `boards`, `user_boards`, `lists`, and `cards` tables. It defines policies to control insert, select, update, and delete operations, ensuring that users can only access or modify data related to their authenticated user ID or boards they are part of, leveraging the `get_boards_for_authenticated_user` function.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2022-08-24-building-a-realtime-trello-board-with-supabase-and-angular.mdx#_snippet_1

LANGUAGE: sql
CODE:
```
-- boards row level security
alter table boards enable row level security;

-- Policies
create policy "Users can create boards" on boards for
  insert to authenticated with CHECK (true);

create policy "Users can view their boards" on boards for
    select using (
      id in (
        select get_boards_for_authenticated_user()
      )
    );

create policy "Users can update their boards" on boards for
    update using (
      id in (
        select get_boards_for_authenticated_user()
      )
    );

create policy "Users can delete their created boards" on boards for
    delete using ((select auth.uid()) = creator);

-- user_boards row level security
alter table user_boards enable row level security;

create policy "Users can add their boards" on user_boards for
    insert to authenticated with check (true);

create policy "Users can view boards" on user_boards for
    select using ((select auth.uid()) = user_id);

create policy "Users can delete their boards" on user_boards for
    delete using ((select auth.uid()) = user_id);

-- lists row level security
alter table lists enable row level security;

-- Policies
create policy "Users can edit lists if they are part of the board" on lists for
    all using (
      board_id in (
        select get_boards_for_authenticated_user()
      )
    );

-- cards row level security
alter table cards enable row level security;

-- Policies
```

----------------------------------------

TITLE: Seeding Initial Role Permissions in SQL
DESCRIPTION: This SQL insert statement populates the `role_permissions` table with initial data, defining which permissions are granted to the 'admin' and 'moderator' roles. It assigns 'channels.delete' and 'messages.delete' to 'admin', and only 'messages.delete' to 'moderator', establishing the base access control rules.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/postgres/custom-claims-and-role-based-access-control-rbac.mdx#_snippet_2

LANGUAGE: sql
CODE:
```
insert into public.role_permissions (role, permission)
values
  ('admin', 'channels.delete'),
  ('admin', 'messages.delete'),
  ('moderator', 'messages.delete');
```

----------------------------------------

TITLE: Implementing Custom Access Token Auth Hook in PL/pgSQL
DESCRIPTION: This PL/pgSQL function, `custom_access_token_hook`, is designed to run as a Supabase Auth Hook before a JWT is issued. It fetches the user's role from the `user_roles` table and injects it as a `user_role` custom claim into the JWT, enabling role-based access control. The script also includes necessary `GRANT` and `REVOKE` statements to manage permissions for the function and the `user_roles` table, ensuring secure execution within the Supabase environment.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/postgres/custom-claims-and-role-based-access-control-rbac.mdx#_snippet_3

LANGUAGE: plpgsql
CODE:
```
-- Create the auth hook function
create or replace function public.custom_access_token_hook(event jsonb)
returns jsonb
language plpgsql
stable
as $$
  declare
    claims jsonb;
    user_role public.app_role;
  begin
    -- Fetch the user role in the user_roles table
    select role into user_role from public.user_roles where user_id = (event->>'user_id')::uuid;

    claims := event->'claims';

    if user_role is not null then
      -- Set the claim
      claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
    else
      claims := jsonb_set(claims, '{user_role}', 'null');
    end if;

    -- Update the 'claims' object in the original event
    event := jsonb_set(event, '{claims}', claims);

    -- Return the modified or original event
    return event;
  end;
$$;

grant usage on schema public to supabase_auth_admin;

grant execute
  on function public.custom_access_token_hook
  to supabase_auth_admin;

revoke execute
  on function public.custom_access_token_hook
  from authenticated, anon, public;

grant all
  on table public.user_roles
to supabase_auth_admin;

revoke all
  on table public.user_roles
  from authenticated, anon, public;

create policy "Allow auth admin to read user roles" ON public.user_roles
as permissive for select
to supabase_auth_admin
using (true)
```

----------------------------------------

TITLE: Allow Authenticated Uploads to a Specific Folder
DESCRIPTION: An SQL policy demonstrating how to allow authenticated users to upload files specifically to a folder named `private` within `my_bucket_id`.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/storage/security/access-control.mdx#_snippet_2

LANGUAGE: sql
CODE:
```
create policy "Allow authenticated uploads"
on storage.objects
for insert
to authenticated
with check (
  bucket_id = 'my_bucket_id' and
  (storage.foldername(name))[1] = 'private'
);
```

----------------------------------------

TITLE: Restrict Inserts to Authenticated Users and Specific Bucket
DESCRIPTION: An SQL policy that modifies the previous example to only allow authenticated users to upload assets to a specific bucket identified by `my_bucket_id`.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/storage/security/access-control.mdx#_snippet_1

LANGUAGE: sql
CODE:
```
create policy "policy_name"
on storage.objects for insert to authenticated with check (
    -- restrict bucket
    bucket_id = 'my_bucket_id'
);
```

----------------------------------------

TITLE: Allow Authenticated Uploads to User-Specific Folder
DESCRIPTION: An SQL policy that enables authenticated users to upload files to a folder named after their `users.id` within `my_bucket_id`, using `auth.uid()`.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/storage/security/access-control.mdx#_snippet_3

LANGUAGE: sql
CODE:
```
create policy "Allow authenticated uploads"
on storage.objects
for insert
to authenticated
with check (
  bucket_id = 'my_bucket_id' and
  (storage.foldername(name))[1] = (select auth.uid()::text)
);
```

----------------------------------------

TITLE: Enable Row Level Security and anonymous access
DESCRIPTION: Turn on Row Level Security for the 'todos' table and create a policy to allow anonymous users to select data. This is for example purposes; secure your production application appropriately.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/realtime/postgres-changes.mdx#_snippet_1

LANGUAGE: sql
CODE:
```
-- Turn on security
alter table "todos"
enable row level security;

-- Allow anonymous access
create policy "Allow anonymous access"
on todos
for select
to anon
using (true);
```

----------------------------------------

TITLE: Set Permissions for Failed Password Attempts Table
DESCRIPTION: This SQL snippet grants all permissions on the `public.password_failed_verification_attempts` table to `supabase_auth_admin` and revokes all permissions from `authenticated`, `anon`, and `public` roles, ensuring secure access control.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-hooks/password-verification-hook.mdx#_snippet_6

LANGUAGE: sql
CODE:
```
grant all
  on table public.password_failed_verification_attempts
  to supabase_auth_admin;

revoke all
  on table public.password_failed_verification_attempts
  from authenticated, anon, public;
```

----------------------------------------

TITLE: Enable Row Level Security and Public Access for 'todos' table
DESCRIPTION: Activates Row Level Security on the 'todos' table and creates a policy to allow anonymous users to select data.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/api/quickstart.mdx#_snippet_1

LANGUAGE: SQL
CODE:
```
-- Turn on security
alter table "todos"
enable row level security;

-- Allow anonymous access
create policy "Allow public access"
  on todos
  for select
  to anon
  using (true);
```

----------------------------------------

TITLE: Grant and Revoke Permissions on job_queue Table
DESCRIPTION: These SQL commands set the necessary permissions for the `job_queue` table. They grant `supabase_auth_admin` full access to manage jobs while revoking access from `authenticated` and `anon` users to maintain security and control over the job queue.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-hooks/send-email-hook.mdx#_snippet_4

LANGUAGE: SQL
CODE:
```
grant all
  on table public.job_queue
  to supabase_auth_admin;

revoke all
  on table public.job_queue
  from authenticated, anon;
```

----------------------------------------

TITLE: Create Row-Level Security Policy for Realtime Broadcast
DESCRIPTION: Sets up a Row-Level Security (RLS) policy on the `realtime.messages` table. This policy grants authenticated users permission to select (receive) broadcast messages, ensuring that only authorized clients can access the real-time data stream.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2025-04-02-realtime-broadcast-from-database.mdx#_snippet_0

LANGUAGE: SQL
CODE:
```
create policy "Authenticated users can receive broadcasts"
on "realtime"."messages"
for select
to authenticated
using ( true );
```

----------------------------------------

TITLE: Configure Row Level Security for User Profiles
DESCRIPTION: Enables Row Level Security (RLS) on the 'profiles' table and defines policies to control access. Policies allow public viewing, users to insert their own profile, and users to update their own profile, ensuring data privacy and integrity.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/_partials/user_management_quickstart_sql_template.mdx#_snippet_1

LANGUAGE: SQL
CODE:
```
-- Set up Row Level Security (RLS)
-- See https://supabase.com/docs/guides/database/postgres/row-level-security for more details.
alter table profiles
  enable row level security;

create policy "Public profiles are viewable by everyone." on profiles
  for select using (true);

create policy "Users can insert their own profile." on profiles
  for insert with check ((select auth.uid()) = id);

create policy "Users can update own profile." on profiles
  for update using ((select auth.uid()) = id);
```

----------------------------------------

TITLE: Granting Execute Permission to Supabase Auth Admin (SQL)
DESCRIPTION: This SQL command grants the `supabase_auth_admin` role permission to execute a specific public function, such as an Auth Hook. This is crucial for Supabase Auth to access and run the hook securely.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-hooks.mdx#_snippet_4

LANGUAGE: SQL
CODE:
```
grant execute
  on function public.custom_access_token_hook
  to supabase_auth_admin;
```

----------------------------------------

TITLE: Create RLS Policy for Read Access to Specific Realtime Extensions
DESCRIPTION: SQL policy showing how to grant read access (SELECT) only to specific Realtime extensions (Broadcast and Presence) by checking the `extension` column in the `realtime.messages` table. This allows fine-grained control over which Realtime features users can access.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2024-08-13-supabase-realtime-broadcast-and-presence-authorization.mdx#_snippet_3

LANGUAGE: sql
CODE:
```
create policy "read access to broadcast and presence"
on "realtime"."messages"
as permissive
for select
to authenticated
using (
  realtime.messages.extension in ('broadcast', 'presence') -- specify the topic name
);
```

----------------------------------------

TITLE: Create Profiles Table for RLS Example
DESCRIPTION: Defines a basic `profiles` table with `id`, `name`, and `email` columns. This table serves as the primary example for demonstrating how Row Level Security can be applied to control data access during partial data dumps.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2022-06-28-partial-postgresql-data-dumps-with-rls.mdx#_snippet_0

LANGUAGE: sql
CODE:
```
create table profiles (
  id serial primary key,
  name text,
  email text
);
```

----------------------------------------

TITLE: Supabase Postgres Row Level Security and Storage Setup
DESCRIPTION: This SQL script defines the `profiles` table, enabling row-level security policies to control access: public viewability, and allowing users to insert and update only their own profiles. It also configures Realtime for the `profiles` table and sets up a storage bucket named 'avatars' with public access policies for image uploads.
SOURCE: https://github.com/supabase/supabase/blob/master/examples/user-management/react-user-management/README.md#_snippet_1

LANGUAGE: SQL
CODE:
```
-- Create a table for Public Profiles
create table
  profiles (
    id uuid references auth.users not null,
    updated_at timestamp
    with
      time zone,
      username text unique,
      avatar_url text,
      website text,
      primary key (id),
      unique (username),
      constraint username_length check (char_length(username) >= 3)
  );

alter table
  profiles enable row level security;

create policy "Public profiles are viewable by everyone." on profiles for
select
  using (true);

create policy "Users can insert their own profile." on profiles for insert
with
  check ((select auth.uid()) = id);

create policy "Users can update own profile." on profiles for
update
  using ((select auth.uid()) = id);

-- Set up Realtime!
begin;

drop
  publication if exists supabase_realtime;

create publication supabase_realtime;

commit;

alter
  publication supabase_realtime add table profiles;

-- Set up Storage!
insert into
  storage.buckets (id, name)
values
  ('avatars', 'avatars');

create policy "Avatar images are publicly accessible." on storage.objects for
select
  using (bucket_id = 'avatars');

create policy "Anyone can upload an avatar." on storage.objects for insert
with
  check (bucket_id = 'avatars');
```

----------------------------------------

TITLE: Postgres RLS policy snippet for `amr` claim access
DESCRIPTION: This Postgres SQL snippet demonstrates how to access the most recent authentication method from the `amr` claim within a Supabase JWT for use in Row Level Security (RLS) policies. It utilizes `jsonb_path_query` to extract the first element of the `amr` array, enabling granular access control based on a user's most recent authentication method and timestamp.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-mfa.mdx#_snippet_9

LANGUAGE: sql
CODE:
```
jsonb_path_query((select auth.jwt()), '$.amr[0]')
```

----------------------------------------

TITLE: Restricting Application Access to SSO Users (SQL)
DESCRIPTION: This SQL function defines a hook to restrict application access, for example, by requiring employees to log in via SAML Single Sign-On (SSO). It declares variables to capture the authentication method and email claim, which would then be used to enforce the policy. The provided snippet is incomplete but sets up the function signature and initial variable declarations for such a hook.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-hooks/custom-access-token-hook.mdx#_snippet_4

LANGUAGE: SQL
CODE:
```
create or replace function public.restrict_application_access(event jsonb)
 returns jsonb
 language plpgsql
as $function$
declare
    authentication_method text;
    email_claim text;
```

----------------------------------------

TITLE: Granting Permissions for Supabase Auth Admin in SQL
DESCRIPTION: This SQL snippet demonstrates how to configure permissions for a Postgres function used as a Supabase hook. It grants `execute` permission on the function and `usage` on the schema to `supabase_auth_admin`, while revoking `execute` permissions from `authenticated`, `anon`, and `public` roles to prevent access via Supabase Data APIs. This ensures the function is only accessible by Supabase Auth.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-hooks.mdx#_snippet_0

LANGUAGE: sql
CODE:
```
-- Grant access to function to supabase_auth_admin
grant execute
  on function public.custom_access_token_hook
  to supabase_auth_admin;

-- Grant access to schema to supabase_auth_admin
grant usage on schema public to supabase_auth_admin;

-- Revoke function permissions from authenticated, anon and public
revoke execute
  on function public.custom_access_token_hook
  from authenticated, anon, public;
```

----------------------------------------

TITLE: Implement Row Level Security for Multi-Tenancy with SSO
DESCRIPTION: This SQL snippet illustrates how to apply Row Level Security (RLS) in PostgreSQL to enforce multi-tenancy. It restricts access to rows based on a `tenant_id` column, matching it with the `provider` identifier extracted from the authenticated user's JWT `app_metadata`.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2023-04-13-supabase-auth-sso-pkce.mdx#_snippet_2

LANGUAGE: sql
CODE:
```
create policy "Only allow read-write access to tenants" on tablename as restrictive to authenticated using (
  tenant_id = (select auth.jwt() -> 'app_metadata' ->> 'provider')
);
```

----------------------------------------

TITLE: Role-Based Access Control Email Examples
DESCRIPTION: Illustrates how to use email plus addressing to assign 'admin' and 'moderator' roles to users upon signup, enabling role-based access control within the application.
SOURCE: https://github.com/supabase/supabase/blob/master/examples/slack-clone/nextjs-slack-clone/README.md#_snippet_3

LANGUAGE: Text
CODE:
```
// admin user
email+supaadmin@example.com

// moderator user
email+supamod@example.com
```

----------------------------------------

TITLE: SQL: Initial RLS Policy for Role-Based Access
DESCRIPTION: Defines a Row Level Security policy on `test_table` for authenticated users, checking if their `user_id` exists in `roles_table` with a 'good_role'. This policy involves a subquery to `roles_table`.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/postgres/row-level-security.mdx#_snippet_18

LANGUAGE: SQL
CODE:
```
create policy "rls_test_select" on test_table
to authenticated
using (
  exists (
    select 1 from roles_table
    where (select auth.uid()) = user_id and role = 'good_role'
  )
);
```

----------------------------------------

TITLE: Prepare Restricted PostgreSQL User for Data Export
DESCRIPTION: Creates a new PostgreSQL user named `exporter` with a specified password. This user is then granted `usage` on the `public` schema and `select` privileges on the `profiles` table, establishing the necessary permissions for controlled data access while adhering to RLS policies.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2022-06-28-partial-postgresql-data-dumps-with-rls.mdx#_snippet_1

LANGUAGE: sql
CODE:
```
-- Create a new user with login privileges
create user exporter
  with password 'exporter_secure_password';

-- Allow this user to select the rows we need
grant usage on schema public to exporter;
grant select on profiles to exporter;
```

----------------------------------------

TITLE: Restricting Application Access with PostgreSQL Function
DESCRIPTION: This PostgreSQL function restricts access to an application based on the user's email domain, authentication method (specifically SAML SSO), or a predefined allowlist of email addresses. It extracts the email and authentication method from the event claims and returns an error if the conditions are not met. The snippet also includes `GRANT` and `REVOKE` statements to manage execution permissions for the function.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-hooks/custom-access-token-hook.mdx#_snippet_5

LANGUAGE: SQL
CODE:
```
allowed_emails text[] := array['myemail@company.com', 'example@company.com'];
begin
    -- Extract email claim and authentication method
    email_claim = event->'claims'->>'email';
    authentication_method = event->'authentication_method';
    -- Authentication methods come double quoted (e.g. "otp")
    authentication_method = replace(authentication_method, '"', '');

    if email_claim ilike '%@supabase.io' or authentication_method = 'sso/saml' or email_claim = any(allowed_emails) then
        return event;
    end if;

    -- If none of the conditions are met, return an error
    return jsonb_build_object(
        'error', jsonb_build_object(
            'http_code', 403,
            'message', 'Staging access is only allowed to team members. Please use your @company.com account instead'
        )
    );
end;
$function$
;
-- manually added
grant execute
  on function public.restrict_application_access
  to supabase_auth_admin;

revoke execute
  on function public.restrict_application_access
  from authenticated, anon, public;
```

----------------------------------------

TITLE: Defining RLS Policies for Anonymous and Permanent Users - SQL
DESCRIPTION: These SQL policies define Row-Level Security (RLS) for the `news_feed` table in Supabase. The first policy restricts `INSERT` operations to only permanent users by checking the `is_anonymous` claim in the JWT, while the second policy allows both anonymous and permanent authenticated users to `SELECT` data. These policies ensure fine-grained access control based on user anonymity status.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-anonymous.mdx#_snippet_15

LANGUAGE: SQL
CODE:
```
create policy "Only permanent users can post to the news feed"
on news_feed as restrictive for insert
to authenticated
with check ((select (auth.jwt()->>'is_anonymous')::boolean) is false );

create policy "Anonymous and permanent users can view the news feed"
on news_feed for select
to authenticated
using ( true );
```

----------------------------------------

TITLE: Manage Prisma Database User in Supabase
DESCRIPTION: SQL commands to create a dedicated Prisma user with necessary permissions on the public schema in Supabase Postgres, and to alter its password. This user provides controlled access and improved monitoring capabilities for Prisma.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/prisma.mdx#_snippet_0

LANGUAGE: sql
CODE:
```
-- Create custom user
create user "prisma" with password 'custom_password' bypassrls createdb;

-- extend prisma's privileges to postgres (necessary to view changes in Dashboard)
grant "prisma" to "postgres";

-- Grant it necessary permissions over the relevant schemas (public)
grant usage on schema public to prisma;
grant create on schema public to prisma;
grant all on all tables in schema public to prisma;
grant all on all routines in schema public to prisma;
grant all on all sequences in schema public to prisma;
alter default privileges for role postgres in schema public grant all on tables to prisma;
alter default privileges for role postgres in schema public grant all on routines to prisma;
alter default privileges for role postgres in schema public grant all on sequences to prisma;
```

LANGUAGE: sql
CODE:
```
-- alter prisma password if needed
alter user "prisma" with password 'new_password';
```

----------------------------------------

TITLE: Add RLS policy to allow public read access (SQL)
DESCRIPTION: This SQL snippet creates a Row Level Security (RLS) policy named 'public can read instruments' on the 'public.instruments' table. This policy allows anonymous users to select (read) data from the table, making it publicly accessible.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/_partials/quickstart_db_setup.mdx#_snippet_1

LANGUAGE: SQL
CODE:
```
create policy "public can read instruments"
on public.instruments
for select to anon
using (true);
```

----------------------------------------

TITLE: Restricting Access to SSO Users via Deno Webhook
DESCRIPTION: This Deno-based HTTP webhook enforces access restrictions, requiring users to authenticate via SAML Single Sign-On (SSO) or be on an explicit email allowlist. It verifies the incoming payload and, based on the `authentication_method` and `claims.email`, either allows access by returning the claims or denies it with an 'Unauthorized' error.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-hooks/custom-access-token-hook.mdx#_snippet_7

LANGUAGE: JavaScript
CODE:
```
import { Webhook } from 'https://esm.sh/standardwebhooks@1.0.0'
import { readAll } from 'https://deno.land/std/io/read_all.ts'
import * as base64 from 'https://denopkg.com/chiefbiiko/base64/mod.ts'

Deno.serve(async (req) => {
  const payload = await req.text()
  const base64_secret = Deno.env.get('CUSTOM_ACCESS_TOKEN_SECRET').replace('v1,whsec_', '')
  const headers = Object.fromEntries(req.headers)
  const wh = new Webhook(base64_secret)
  try {
    const { user_id, claims, authentication_method } = wh.verify(payload, headers)

    // Check the condition
    const allowedEmails = ['myemail@company.com', 'example@company.com']
    if (authentication_method === 'sso/saml' || allowedEmails.includes(claims.email)) {
      return new Response(
        JSON.stringify({
          claims,
        }),
        {
          status: 200,
          headers: {
            'Content-Type': 'application/json',
          },
        }
      )
    } else {
      return new Response(
        JSON.stringify({
          error: 'Unauthorized',
        }),
        {
          status: 500,
          headers: {
            'Content-Type': 'application/json',
          },
        }
      )
    }
  } catch (error) {
    return new Response(
      JSON.stringify({
        error: `Failed to process the request: ${error}`,
      }),
      {
        status: 500,
        headers: {
          'Content-Type': 'application/json',
        },
      }
    )
  }
})
```

----------------------------------------

TITLE: Enforce Multi-Factor Authentication with auth.jwt() in RLS
DESCRIPTION: Illustrates how to create a restrictive Row Level Security policy that prevents users from updating their profiles unless their authentication assurance level (AAL) is 'aal2', indicating at least two levels of authentication. This uses the `auth.jwt()` function to access the 'aal' claim.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/postgres/row-level-security.mdx#_snippet_13

LANGUAGE: SQL
CODE:
```
create policy "Restrict updates."
on profiles
as restrictive
for update
to authenticated using (
  (select auth.jwt()->>'aal') = 'aal2'
);
```

----------------------------------------

TITLE: Revoking Execute Permission from Public Roles (SQL)
DESCRIPTION: This SQL command revokes execute permissions on a specific public function from the `authenticated` and `anon` roles. This ensures that the Auth Hook is not directly accessible via Supabase Serverless APIs, enhancing security.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-hooks.mdx#_snippet_6

LANGUAGE: SQL
CODE:
```
revoke execute
  on function public.custom_access_token_hook
  from authenticated, anon;
```

----------------------------------------

TITLE: Create SELECT policies for authenticated and unauthenticated roles
DESCRIPTION: Examples of RLS policies demonstrating the use of the `TO` clause to grant `SELECT` access based on Postgres roles. The first policy allows both `authenticated` and `anon` users to view profiles, while the second restricts access to `authenticated` users only.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/postgres/row-level-security.mdx#_snippet_3

LANGUAGE: SQL
CODE:
```
create policy "Profiles are viewable by everyone"
on profiles for select
to authenticated, anon
using ( true );
```

LANGUAGE: SQL
CODE:
```
create policy "Public profiles are viewable only by authenticated users"
on profiles for select
to authenticated
using ( true );
```

----------------------------------------

TITLE: Configure Storage Access Policies for Avatars
DESCRIPTION: Defines access control policies for the 'avatars' storage bucket. These policies allow avatar images to be publicly accessible for viewing, permit anyone to upload an avatar, and enable users to update their own avatars.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/_partials/user_management_quickstart_sql_template.mdx#_snippet_4

LANGUAGE: SQL
CODE:
```
-- Set up access controls for storage.
-- See https://supabase.com/docs/guides/storage/security/access-control#policy-examples for more details.
create policy "Avatar images are publicly accessible." on storage.objects
  for select using (bucket_id = 'avatars');

create policy "Anyone can upload an avatar." on storage.objects
  for insert with check (bucket_id = 'avatars');

create policy "Anyone can update their own avatar." on storage.objects
  for update using ((select auth.uid()) = owner) with check (bucket_id = 'avatars');
```

----------------------------------------

TITLE: Create Supabase Public Schema Tables for Chat Application
DESCRIPTION: SQL script to create `public.rooms`, `public.profiles`, and `public.rooms_users` tables. These tables are fundamental for managing chat rooms, user profiles, and the association between users and rooms, respectively. Row Level Security (RLS) is enabled for all tables to enforce access control.
SOURCE: https://github.com/supabase/supabase/blob/master/examples/realtime/nextjs-authorization-demo/README.md#_snippet_0

LANGUAGE: sql
CODE:
```
CREATE TABLE public.rooms (
    id bigint GENERATED BY default AS IDENTITY PRIMARY KEY,
    topic text NOT NULL UNIQUE
);
ALTER TABLE public.rooms ENABLE ROW LEVEL SECURITY;

CREATE TABLE public.profiles (
  id uuid NOT NULL REFERENCES auth.users ON DELETE CASCADE,
  email text NOT NULL,

  PRIMARY KEY (id)
);
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

CREATE TABLE public.rooms_users (
  user_id uuid REFERENCES auth.users (id),
  room_topic text REFERENCES public.rooms (topic),
  created_at timestamptz DEFAULT CURRENT_TIMESTAMP
);
ALTER TABLE public.rooms_users ENABLE ROW LEVEL SECURITY;
```

----------------------------------------

TITLE: Create SELECT policy for user's own profiles
DESCRIPTION: An alternative RLS policy for the `profiles` table, restricting `SELECT` access so that users can only view their own profile records by matching `auth.uid()` with the `user_id` column.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/postgres/row-level-security.mdx#_snippet_5

LANGUAGE: SQL
CODE:
```
create policy "User can see their own profile only."
on profiles
for select using ( (select auth.uid()) = user_id );
```

----------------------------------------

TITLE: Access Data with Supabase Service Role Key using cURL
DESCRIPTION: Shows how to use the `service role key` for super admin access to your Supabase project. This key grants full bypass of Row Level Security and should only be used in secure, server-side environments, never client-side.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/jwts.mdx#_snippet_12

LANGUAGE: bash
CODE:
```
curl "$YOUR_PROJECT_URL/rest/v1/colors?select=name" \
 -H "apikey: $YOUR_SERVICE_ROLE_KEY" \
 -H "authorization: Bearer $YOUR_SERVICE_ROLE_KEY"
```

----------------------------------------

TITLE: Alter and Create SQL Views with Security Invoker
DESCRIPTION: This snippet demonstrates how to alter an existing security definer view to be security invoker, and how to create a new view with the security invoker modifier. Using 'security invoker' enforces row-level security policies by having the view accessed with the invoker's permissions, rather than the creator's.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/tables.mdx#_snippet_12

LANGUAGE: sql
CODE:
```
-- alter a security_definer view to be security_invoker
alter view <view name>
set (security_invoker = true);

-- create a view with the security_invoker modifier
create view <view name> with(security_invoker=true) as (
  select * from <some table>
);
```

----------------------------------------

TITLE: API Doc: auth.uid() Helper Function
DESCRIPTION: Documentation for the auth.uid() helper function provided by Supabase. This function returns the unique identifier (ID) of the currently authenticated user making the request, commonly used in RLS policies for user-specific access control.
SOURCE: https://github.com/supabase/supabase/blob/master/examples/prompts/database-rls-policies.md#_snippet_6

LANGUAGE: APIDOC
CODE:
```
auth.uid()
  Returns the ID of the user making the request.
```

----------------------------------------

TITLE: Grant Bypass RLS Privilege to a Postgres Role
DESCRIPTION: Shows how to alter a Postgres role to grant it the `bypassrls` privilege, allowing it to ignore Row Level Security policies. This is useful for system-level administrative access but should never be shared with end-users.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/postgres/row-level-security.mdx#_snippet_14

LANGUAGE: SQL
CODE:
```
alter role "role_name" with bypassrls;
```

----------------------------------------

TITLE: RLS Policy to Restrict Organization Settings Access by SSO Provider
DESCRIPTION: A Row Level Security policy for the `organization_settings` table that restricts access to rows where the `sso_provider_id` matches the SSO identity provider UUID from the user's JWT. This enables multi-tenancy based on SSO by ensuring users only see data relevant to their organization.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/enterprise-sso/auth-sso-saml.mdx#_snippet_3

LANGUAGE: SQL
CODE:
```
CREATE POLICY "View organization settings."
  ON organization_settings
  AS RESTRICTIVE
  USING (
    sso_provider_id = (select auth.jwt()#>>'{amr,0,provider}')
  );
```

----------------------------------------

TITLE: Migrating from auth.email() to auth.jwt() for email-based RLS
DESCRIPTION: The `auth.email()` function for Row Level Security (RLS) in Supabase is deprecated. This snippet shows how to update policies to extract the user's email directly from the `auth.jwt()` function, providing a more generic and recommended approach for email-based access control.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/troubleshooting/deprecated-rls-features-Pm77Zs.mdx#_snippet_1

LANGUAGE: SQL
CODE:
```
- DEPRECATED
create policy "User can view their profile."
on profiles for select using (
  auth.email() = email
);
```

LANGUAGE: SQL
CODE:
```
-- RECOMMENDED
create policy "User can view their profile."
on profiles for select using (
  (auth.jwt() ->> 'email') = email
);
```

----------------------------------------

TITLE: Allow authenticated users to send Broadcast messages with RLS
DESCRIPTION: This SQL policy grants `insert` permissions on `realtime.messages` to authenticated users for 'broadcast' messages. It ensures that only users linked to the channel's topic in the `rooms_users` table can send messages, enforcing secure write access.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/realtime/authorization.mdx#_snippet_4

LANGUAGE: SQL
CODE:
```
create policy "authenticated can send broadcast on topic"
on "realtime"."messages"
for insert
to authenticated
with check (
  exists (
    select
      user_id
    from
      rooms_users
    where
      user_id = (select auth.uid())
      and topic = (select realtime.topic())
      and realtime.messages.extension in ('broadcast')
  )
);
```

----------------------------------------

TITLE: Supabase Profiles Table and Security Policies
DESCRIPTION: This SQL script defines the `profiles` table, which stores user profile information linked to `auth.users`. It includes columns for `id`, `updated_at`, `username`, `avatar_url`, and `website`. The script also establishes Row Level Security (RLS) policies for `profiles` to control read, insert, and update access, ensuring users can only manage their own profiles. Furthermore, it configures Supabase Realtime for the `profiles` table and sets up a `storage.buckets` entry for 'avatars' with RLS policies for public access and upload.
SOURCE: https://github.com/supabase/supabase/blob/master/examples/user-management/vue3-user-management/README.md#_snippet_1

LANGUAGE: sql
CODE:
```
-- Create a table for public "profiles"
create table profiles (
  id uuid references auth.users not null,
  updated_at timestamp with time zone,
  username text unique,
  avatar_url text,
  website text,

  primary key (id),
  unique(username),
  constraint username_length check (char_length(username) >= 3)
);

alter table profiles enable row level security;

create policy "Public profiles are viewable by everyone."
  on profiles for select
  using ( true );

create policy "Users can insert their own profile."
  on profiles for insert
  with check ( (select auth.uid()) = id );

create policy "Users can update own profile."
  on profiles for update
  using ( (select auth.uid()) = id );

-- Set up Realtime!
begin;
  drop publication if exists supabase_realtime;
  create publication supabase_realtime;
commit;
alter publication supabase_realtime add table profiles;

-- Set up Storage!
insert into storage.buckets (id, name)
values ('avatars', 'avatars');

create policy "Avatar images are publicly accessible."
  on storage.objects for select
  using ( bucket_id = 'avatars' );

create policy "Anyone can upload an avatar."
  on storage.objects for insert
  with check ( bucket_id = 'avatars' );
```

----------------------------------------

TITLE: Supabase Auth: Enforcing Row Level Security with SQL Policy
DESCRIPTION: This SQL policy demonstrates how Supabase Auth leverages PostgreSQL's Row Level Security (RLS) to restrict data access. It ensures that users can only view documents where their 'user_id' matches the authenticated user's UID, providing robust database-level authorization.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_alternatives/supabase-vs-auth0.mdx#_snippet_0

LANGUAGE: sql
CODE:
```
create policy "Users can only view their own documents."
on docs for select
using ( (select auth.uid()) = user_id );
```

----------------------------------------

TITLE: Add SQL for table creation and column-level privileges
DESCRIPTION: Define a 'posts' table with identity primary key, user ID, title, content, and timestamps. Implement row-level security to allow updates only for owners and apply column-level security to revoke 'update' privilege on the 'title' column from authenticated users.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/postgres/column-level-security.mdx#_snippet_4

LANGUAGE: sql
CODE:
```
create table
posts (
id bigint primary key generated always as identity,
user_id text,
title text,
content text,
created_at timestamptz default now()
updated_at timestamptz default now()
);

-- Add row-level security
create policy "Allow update for owners" on posts for
update
using ((select auth.uid()) = user_id);

-- Add column-level security
revoke
update
(title) on table public.posts
from
authenticated;
```

----------------------------------------

TITLE: Access Request Information in Postgres
DESCRIPTION: These SQL queries demonstrate how to access various pieces of request information, such as headers, cookies, and JWT payload, within a Postgres function using the `current_setting()` function. This allows for dynamic logic based on incoming request data.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/api/securing-your-api.mdx#_snippet_6

LANGUAGE: sql
CODE:
```
-- To get all the headers sent in the request
SELECT current_setting('request.headers', true)::json;

-- To get a single header, you can use JSON arrow operators
SELECT current_setting('request.headers', true)::json->>'user-agent';

-- Access Cookies
SELECT current_setting('request.cookies', true)::json;
```

----------------------------------------

TITLE: Enforce MFA for All Users with Supabase Row Level Security Policy
DESCRIPTION: Provides a PostgreSQL Row Level Security (RLS) policy template to enforce Multi-Factor Authentication (MFA) for all users accessing a specific table. This policy restricts access to only those users whose JWT `aal` claim is `aal2` (highest assurance level), ensuring MFA completion. The `as restrictive` clause ensures this policy overrides others.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-mfa.mdx#_snippet_3

LANGUAGE: SQL
CODE:
```
create policy "Policy name."
  on table_name
  as restrictive
  to authenticated
  using ((select auth.jwt()->>'aal') = 'aal2');
```

----------------------------------------

TITLE: SQL RLS Policy: Allow Authenticated Users to Read Messages on Specific Topic
DESCRIPTION: This SQL RLS policy demonstrates how to restrict read access to the `realtime.messages` table for authenticated users, allowing them to receive broadcasts only from a specific channel topic, 'room-1', by utilizing the `realtime.topic()` helper function.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/realtime/authorization.mdx#_snippet_0

LANGUAGE: SQL
CODE:
```
create policy "authenticated can read all messages on topic"
on "realtime"."messages"
for select
to authenticated
using (
  (select realtime.topic()) = 'room-1'
);
```

----------------------------------------

TITLE: SQL: Update RLS Policy to Use Security Definer Function
DESCRIPTION: Updates the Row Level Security policy on `test_table` to use the `private.has_good_role()` security definer function. This simplifies the policy's `using` clause and improves performance by leveraging the privileged function.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/postgres/row-level-security.mdx#_snippet_20

LANGUAGE: SQL
CODE:
```
-- Update our policy to use this function:
create policy "rls_test_select"
on test_table
to authenticated
using ( private.has_good_role() );
```

----------------------------------------

TITLE: SQL: Enable RLS and Create Policy for Document Sections
DESCRIPTION: Enables Row Level Security on the `document_sections` table and creates a policy that restricts `select` operations. Users can only query document sections if they own the linked parent document, using `auth.uid()` for authentication.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/ai/rag-with-permissions.mdx#_snippet_1

LANGUAGE: sql
CODE:
```
-- enable row level security
alter table document_sections enable row level security;

-- setup RLS for select operations
create policy "Users can query their own document sections"
on document_sections for select to authenticated using (
  document_id in (
    select id
    from documents
    where (owner_id = (select auth.uid()))
  )
);
```