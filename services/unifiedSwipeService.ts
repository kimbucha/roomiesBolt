/**
 * Unified Swipe Service - Supabase Single Source of Truth
 * 
 * This service replaces the multiple conflicting stores (roommateStore, matchesStore, etc.)
 * with a single unified system using Supabase as the source of truth.
 * 
 * Key Features:
 * - Handles both user-to-user and user-to-place swipes
 * - Creates matches automatically when mutual interest is detected
 * - Real-time sync across devices
 * - No local state persistence - everything in Supabase
 */

import { supabase } from './supabaseClient';
import { User } from '@supabase/supabase-js';
import { RoommateProfile, useRoommateStore } from '../store/roommateStore'; // Use the existing type

// Types for the unified system
export interface SwipeRecord {
  id: string;
  user_id: string;
  target_profile_id: string;
  swipe_type: 'like' | 'dislike' | 'super_like';
  swiped_at: string;
  created_at: string;
  updated_at: string;
}

export interface MatchRecord {
  id: string;
  user_id: string;
  target_profile_id: string;
  target_user_id: string;
  match_type: 'regular' | 'super' | 'mixed' | 'place_interest';
  is_mutual: boolean;
  is_active: boolean;
  created_at: string;
  updated_at: string;
  conversation_id?: string;
}

// Re-export RoommateProfile from store for consistency
export { RoommateProfile } from '../store/roommateStore';

// Core swipe operations
export class UnifiedSwipeService {
  private currentUser: User | null = null;

  constructor() {
    this.initializeAuth();
  }

  private async initializeAuth() {
    const { data: { user } } = await supabase.auth.getUser();
    this.currentUser = user;
  }

  /**
   * Record a swipe action in Supabase
   * This replaces all local swipe tracking
   */
  async recordSwipe(targetProfileId: string, swipeType: 'like' | 'dislike' | 'super_like'): Promise<SwipeRecord | null> {
    try {
      if (!this.currentUser) {
        console.error('[UnifiedSwipeService] No authenticated user');
        return null;
      }

      console.log(`[UnifiedSwipeService] Recording ${swipeType} for profile ${targetProfileId}`);

      // Insert swipe record
      const { data: swipeData, error: swipeError } = await supabase
        .from('swipes')
        .insert({
          user_id: this.currentUser.id,
          target_profile_id: targetProfileId,
          swipe_type: swipeType
          // Let created_at be auto-generated by Supabase
        })
        .select()
        .single();

      if (swipeError) {
        if (swipeError.code === '23505') { // Unique constraint violation
          console.log('[UnifiedSwipeService] User already swiped on this profile');
          return null;
        }
        
        // Log the error but don't fail - fall back to local storage
        console.error('[UnifiedSwipeService] Supabase write failed, continuing with local fallback:', swipeError);
        
        // Create a mock swipe record for consistency
        const mockSwipeRecord: SwipeRecord = {
          id: `local-${Date.now()}`,
          user_id: this.currentUser.id,
          target_profile_id: targetProfileId,
          swipe_type: swipeType,
          swiped_at: new Date().toISOString(),
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        };
        
        console.log('[UnifiedSwipeService] Using local fallback record:', mockSwipeRecord);
        return mockSwipeRecord;
      }

      console.log('[UnifiedSwipeService] Swipe recorded in Supabase:', swipeData);

      // If it's a like or super_like, check for matches
      if (swipeType === 'like' || swipeType === 'super_like') {
        try {
          await this.checkAndCreateMatch(targetProfileId, swipeType);
        } catch (matchError) {
          console.log('[UnifiedSwipeService] Match creation failed, but swipe was recorded. This is expected when using local fallback.');
        }
      }

      return swipeData;
    } catch (error) {
      console.error('[UnifiedSwipeService] Error recording swipe:', error);
      return null;
    }
  }

  /**
   * Check if a mutual match exists and create match record
   */
  private async checkAndCreateMatch(targetProfileId: string, swipeType: 'like' | 'super_like') {
    try {
      if (!this.currentUser) return;

      // Get the target profile to find the target user
      const { data: targetProfile, error: profileError } = await supabase
        .from('roommate_profiles')
        .select('id, user_id, hasPlace')
        .eq('id', targetProfileId)
        .single();

      if (profileError || !targetProfile) {
        console.error('[UnifiedSwipeService] Could not find target profile:', profileError);
        return;
      }

      // Determine match type based on target profile
      let matchType: MatchRecord['match_type'] = 'regular';
      let isMutual = false;

      if (targetProfile.hasPlace) {
        // User swiping on a place - always create match for likes
        matchType = 'place_interest';
        isMutual = true; // Place matches are always "mutual" (user expressed interest)
      } else {
        // User swiping on another user - check for mutual interest
        const { data: reverseSwipe } = await supabase
          .from('swipes')
          .select('swipe_type')
          .eq('user_id', targetProfile.user_id)
          .eq('target_profile_id', this.currentUser.id) // Check if they swiped back
          .single();

        if (reverseSwipe && (reverseSwipe.swipe_type === 'like' || reverseSwipe.swipe_type === 'super_like')) {
          isMutual = true;
          // Determine match type
          if (swipeType === 'super_like' && reverseSwipe.swipe_type === 'super_like') {
            matchType = 'super';
          } else if (swipeType === 'super_like' || reverseSwipe.swipe_type === 'super_like') {
            matchType = 'mixed';
          } else {
            matchType = 'regular';
          }
        }
      }

      // Only create match if mutual or place interest
      if (isMutual) {
        await this.createMatch(targetProfileId, targetProfile.user_id, matchType, isMutual);
      }

    } catch (error) {
      console.error('[UnifiedSwipeService] Error checking for match:', error);
    }
  }

  /**
   * Create a match record in Supabase
   */
  private async createMatch(
    targetProfileId: string, 
    targetUserId: string, 
    matchType: MatchRecord['match_type'],
    isMutual: boolean
  ) {
    try {
      if (!this.currentUser) return;

      console.log(`[UnifiedSwipeService] Creating ${matchType} match with profile ${targetProfileId}`);

      const { data: matchData, error: matchError } = await supabase
        .from('matches')
        .insert({
          user_id: this.currentUser.id,
          target_profile_id: targetProfileId,
          target_user_id: targetUserId,
          match_type: matchType,
          is_mutual: isMutual,
          is_active: true
        })
        .select()
        .single();

      if (matchError) {
        if (matchError.code === '23505') { // Unique constraint - match already exists
          console.log('[UnifiedSwipeService] Match already exists');
          return;
        }
        throw matchError;
      }

      console.log('[UnifiedSwipeService] Match created:', matchData);

      // For mutual matches, create conversation
      if (isMutual && matchType !== 'place_interest') {
        await this.createConversation(matchData.id);
      }

    } catch (error) {
      console.error('[UnifiedSwipeService] Error creating match:', error);
    }
  }

  /**
   * Create conversation for a match
   */
  private async createConversation(matchId: string) {
    try {
      const { data: conversation, error } = await supabase
        .from('conversations')
        .insert({
          match_id: matchId,
          is_active: true,
          last_message_at: new Date().toISOString()
        })
        .select()
        .single();

      if (error) throw error;

      console.log('[UnifiedSwipeService] Conversation created:', conversation);
      return conversation;
    } catch (error) {
      console.error('[UnifiedSwipeService] Error creating conversation:', error);
    }
  }

  /**
   * Get all swipes for the current user
   * This replaces roommateStore.swipedProfiles
   */
  async getUserSwipes(): Promise<SwipeRecord[]> {
    try {
      if (!this.currentUser) return [];

      const { data, error } = await supabase
        .from('swipes')
        .select('*')
        .eq('user_id', this.currentUser.id)
        .order('created_at', { ascending: false });

      if (error) throw error;
      return data || [];
    } catch (error) {
      console.error('[UnifiedSwipeService] Error fetching user swipes:', error);
      return [];
    }
  }

  /**
   * Get profiles that the user has NOT swiped on yet
   * This replaces the filtering logic in roommateStore
   */
  async getUnswipedProfiles(): Promise<RoommateProfile[]> {
    try {
      // Check if user is authenticated
      await this.initializeAuth();
      console.log(`[UnifiedSwipeService] Current user check: ${this.currentUser ? 'authenticated' : 'NOT authenticated'}`);
      
      if (!this.currentUser) {
        console.log('[UnifiedSwipeService] No authenticated user, falling back to local profiles immediately');
        const localProfiles = useRoommateStore.getState().profiles;
        console.log(`[UnifiedSwipeService] Emergency fallback: Returning ${localProfiles.length} profiles from local store`);
        return localProfiles;
      }

      // Get all profile IDs the user has swiped on
      const { data: swipedProfileIds } = await supabase
        .from('swipes')
        .select('target_profile_id')
        .eq('user_id', this.currentUser.id);

      const excludeIds = swipedProfileIds?.map((s: any) => s.target_profile_id) || [];
      
      // Also exclude user's own profile
      const { data: userProfile } = await supabase
        .from('roommate_profiles')
        .select('id')
        .eq('user_id', this.currentUser.id)
        .single();

      if (userProfile) {
        excludeIds.push(userProfile.id);
      }

      // Get all profiles NOT in the excluded list
      let query = supabase
        .from('roommate_profiles')
        .select('*');

      if (excludeIds.length > 0) {
        query = query.not('id', 'in', `(${excludeIds.join(',')})`);
      }

      const { data: profiles, error } = await query
        .order('created_at', { ascending: false });

      if (error) throw error;

      console.log(`[UnifiedSwipeService] Found ${profiles?.length || 0} unswiped profiles from Supabase`);

      // FALLBACK: If no profiles in Supabase, use local mock data
      if (!profiles || profiles.length === 0) {
        console.log('[UnifiedSwipeService] No profiles in Supabase, falling back to local mock data');
        
        // Use the imported store
        const localProfiles = useRoommateStore.getState().profiles;
        
        // Filter out profiles the user has swiped on
        const filteredLocalProfiles = localProfiles.filter(profile => 
          !excludeIds.includes(profile.id)
        );
        
        console.log(`[UnifiedSwipeService] Returning ${filteredLocalProfiles.length} profiles from local mock data`);
        return filteredLocalProfiles;
      }

      return profiles || [];
    } catch (error) {
      console.error('[UnifiedSwipeService] Error fetching unswiped profiles:', error);
      
      // FALLBACK on error: Use local mock data
      try {
        console.log('[UnifiedSwipeService] Error occurred, falling back to local mock data');
        const localProfiles = useRoommateStore.getState().profiles;
        
        // Get swipe IDs from any available source
        const { data: swipedProfileIds } = await supabase
          .from('swipes')
          .select('target_profile_id')
          .eq('user_id', this.currentUser!.id) || { data: [] };
        
        const excludeIds = swipedProfileIds?.map((s: any) => s.target_profile_id) || [];
        
        const filteredProfiles = localProfiles.filter(profile => 
          !excludeIds.includes(profile.id)
        );
        
        console.log(`[UnifiedSwipeService] Fallback: Returning ${filteredProfiles.length} profiles from local store`);
        return filteredProfiles;
      } catch (fallbackError) {
        console.error('[UnifiedSwipeService] Fallback also failed:', fallbackError);
        return [];
      }
    }
  }

  /**
   * Get all matches for the current user
   * This replaces matchesStore and supabaseMatchesStore
   */
  async getUserMatches(): Promise<MatchRecord[]> {
    try {
      if (!this.currentUser) return [];

      const { data, error } = await supabase
        .from('matches')
        .select(`
          *,
          target_profile:roommate_profiles!target_profile_id(*)
        `)
        .eq('user_id', this.currentUser.id)
        .eq('is_active', true)
        .order('created_at', { ascending: false });

      if (error) throw error;
      return data || [];
    } catch (error) {
      console.error('[UnifiedSwipeService] Error fetching matches:', error);
      return [];
    }
  }

  /**
   * Check if user has swiped on a specific profile
   * This replaces roommateStore.hasSwipedOn
   */
  async hasSwipedOn(profileId: string): Promise<boolean> {
    try {
      if (!this.currentUser) return false;

      const { data, error } = await supabase
        .from('swipes')
        .select('id')
        .eq('user_id', this.currentUser.id)
        .eq('target_profile_id', profileId)
        .single();

      return !error && !!data;
    } catch (error) {
      return false;
    }
  }

  /**
   * Clear all swipes for the current user (for debugging)
   */
  async clearAllSwipes(): Promise<boolean> {
    try {
      if (!this.currentUser) return false;

      const { error } = await supabase
        .from('swipes')
        .delete()
        .eq('user_id', this.currentUser.id);

      if (error) throw error;
      
      console.log('[UnifiedSwipeService] All swipes cleared for user');
      return true;
    } catch (error) {
      console.error('[UnifiedSwipeService] Error clearing swipes:', error);
      return false;
    }
  }

  /**
   * Reset matches for debugging
   */
  async clearAllMatches(): Promise<boolean> {
    try {
      if (!this.currentUser) return false;

      const { error } = await supabase
        .from('matches')
        .delete()
        .eq('user_id', this.currentUser.id);

      if (error) throw error;
      
      console.log('[UnifiedSwipeService] All matches cleared for user');
      return true;
    } catch (error) {
      console.error('[UnifiedSwipeService] Error clearing matches:', error);
      return false;
    }
  }
}

// Export singleton instance
export const unifiedSwipeService = new UnifiedSwipeService(); 